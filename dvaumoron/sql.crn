#
# Copyright 2023 cornucopiarecipes authors.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

load("dvaumoron/main.crn", "StructType", "MakeFunc", "NewFunc")

# type description fields
TYPE_NAME = "typeName"
TABLE_NAME = "tableName"
PRIMARY_KEY = "primaryKey"
FIELDS = "fields"

# dbInterfaces fields
EXECER_CONTEXT = "execerContext"
QUERYER_CONTEXT = "queryerContext"
ROW_QUERYER_CONTEXT = "rowQueryerContext"

# internal constant
QUERY_METHOD = Id("QueryContext").Call(Id("ctx").Qual("context", "Context"), Id("query").String(), Id("args").Op("...").Any()).Parens(List(Op("*").Qual("database/sql", "Rows"), Error()))
QUERY_ROW_METHOD = Id("QueryRowContext").Call(Id("ctx").Qual("context", "Context"), Id("query").String(), Id("args").Op("...").Any()).Op("*").Qual("database/sql", "Row")
EXEC_METHOD = Id("ExecContext").Call(Id("ctx").Qual("context", "Context"), Id("query").String(), Id("args").Op("...").Any()).Parens(List(Qual("database/sql", "Result"), Error()))
DEFER_CANCEL = Defer().Id("cancel").Call()
DEFER_ROWS_CLOSE = Defer().Id("rows").Dot("Close").Call()
IF_ERR_NOT_NIL = If(Err().Op("!=").Nil()).Block(
    Return(Nil(), Err()),
)
FOR_ROWS_SCAN = For(Id("rows").Dot("Next").Call()).Block(
    Err().Op("=").Id("rows").Dot("Scan").Call(Op("&").Id("valueTemp")),
    IF_ERR_NOT_NIL,
    Id("results").Op("=").Append(Id("results"), Id("valueTemp")),
)
RETURN_RESULTS = Return(Id("results"), Nil())
IF_ERR_NOT_NIL_ZERO = If(Err().Op("!=").Nil()).Block(
    Return(0, Err()),
)

def computeQueryParams(query, poolType, inputFields, varArgsFilter):
    filteredQuery = query
    dollarNumber = "$0"
    for i, k in enumerate(inputFields):
        dollarNumber = "$" + str(i+1)
        filteredQuery = filteredQuery.replace("@" + k, dollarNumber)

    funcParams = [Id("pool").Add(poolType), Id("ctx").Qual("context", "Context")]
    lastParamName = ""
    callParams = [Id("ctx"), Id("query")]
    for k, v in inputFields.items():
        funcParams.append(Id(k).Add(v))
        lastParamName = k
        callParams.append(Id(k))

    queryDeclaration = Id("query").Op(":=")
    if varArgsFilter:
        if lastParamName:
            size = Len(Id(lastParamName))
        else:
            size = Int().Call(Lit(0))
        queryDeclaration.Id(varArgsFilter).Call(filteredQuery, dollarNumber, size)
    else:
        queryDeclaration.Lit(filteredQuery)

    return funcParams, callParams, queryDeclaration

def addTimeOut(timeOutDuration):
    return List(Id("ctx"), Id("cancel")).Op(":=").Qual("context", "WithTimeout").Call(Id("ctx"), timeOutDuration)

def computeConvertParams(queryResultFields, instructions):
    pointedParams = []
    callParams = []
    for k, v in queryResultFields.items():
        k += "Temp"
        instructions.append(Var().Id(k).Add(v))
        pointedParams.append(Op("&").Id(k))
        callParams.append(Id(k))
    return pointedParams, callParams

def insertQuery(typeDesc):
    queryBuilder = ["insert into "]
    queryBuilder.append(typeDesc[TABLE_NAME])
    queryBuilder.append("(")
    first = True
    fieldItems = typeDesc[FIELDS].items()
    for fieldName, fieldData in fieldItems:
        if first:
            first = False
        else:
            queryBuilder.append(", ")
        queryBuilder.append(fieldData[1])
    queryBuilder.append(") values(")
    first = True
    for fieldName, fieldData in fieldItems:
        if first:
            first = False
        else:
            queryBuilder.append(", ")
        queryBuilder.append("@")
        queryBuilder.append(fieldName)
    queryBuilder.append(");")
    return "".join(queryBuilder)

def SelectQuery(typeDesc, *whereClauseParts, alias="o", joins={}):
    queryBuilder = ["select "]
    first = True
    for fieldName, fieldData in typeDesc[FIELDS].items():
        if first:
            first = False
        else:
            queryBuilder.append(", ")
        queryBuilder.append(alias)
        queryBuilder.append(".")
        queryBuilder.append(fieldData[1])
    queryBuilder.append(" from ")
    queryBuilder.append(typeDesc[TABLE_NAME])
    queryBuilder.append(" as ")
    queryBuilder.append(alias)
    for tableName, tableAlias in joins.items():
        queryBuilder.append(", ")
        queryBuilder.append(tableName)
        queryBuilder.append(" as ")
        queryBuilder.append(tableAlias)
    if whereClauseParts:
        queryBuilder.append(" where ")
        queryBuilder.extend(whereClauseParts)
    queryBuilder.append(";")
    return "".join(queryBuilder)

def selectByPrimaryKeyQuery(typeDesc, alias="o"):
    pkName = typeDesc[PRIMARY_KEY]
    return SelectQuery(typeDesc, alias, ".", typeDesc[FIELDS][pkName][1], " = @", pkName, alias=alias)

def updateQuery(typeDesc):
    pkName = typeDesc[PRIMARY_KEY]
    fields = typeDesc[FIELDS]

    queryBuilder = ["update "]
    queryBuilder.append(typeDesc[TABLE_NAME])
    queryBuilder.append(" set ")
    first = True
    for fieldName, fieldData in fields.items():
        if fieldName == pkName:
            continue
        if first:
            first = False
        else:
            queryBuilder.append(", ")
        queryBuilder.append(fieldData[1])
        queryBuilder.append(" = @")
        queryBuilder.append(fieldName)
    queryBuilder.append(" where ")
    queryBuilder.append(fields[pkName][1])
    queryBuilder.append(" = @")
    queryBuilder.append(pkName)
    queryBuilder.append(";")
    return "".join(queryBuilder)

def deleteQuery(typeDesc):
    pkName = typeDesc[PRIMARY_KEY]

    queryBuilder = ["delete from "]
    queryBuilder.append(typeDesc[TABLE_NAME])
    queryBuilder.append(" where ")
    queryBuilder.append(typeDesc[FIELDS][pkName][1])
    queryBuilder.append(" = @")
    queryBuilder.append(pkName)
    queryBuilder.append(";")
    return "".join(queryBuilder)

def ConstDurationSec(file, name, sec):
    file.Const().Id(name).Op("=").Qual("time", "Duration").Call(sec).Op("*").Qual("time", "Second")
    return Id(name)

def ExecerContext(file, name):
    file.Type().Id(name).Interface(
        EXEC_METHOD,
    )

def QueryerContext(file, name):
    file.Type().Id(name).Interface(
        QUERY_METHOD,
    )

def RowQueryerContext(file, name):
    file.Type().Id(name).Interface(
        QUERY_ROW_METHOD,
    )

def DeclareDBInterfaces(file, execerName, queryerName, rowQueryerName):
    ExecerContext(file, execerName)
    file.Line()
    RowQueryerContext(file, rowQueryerName)
    file.Line()
    QueryerContext(file, queryerName)
    return {
        EXECER_CONTEXT: Id(execerName),
        QUERYER_CONTEXT: Id(queryerName),
        ROW_QUERYER_CONTEXT: Id(rowQueryerName),
    }

def DeclareVarArgsFilter(file, name):
    file.Func().Id(name).Params(Id("query").String(), Id("placeholder").String(), Id("size").Int() ).String().Block(
        # TODO
        Return(Id("query"))
    )

def SimpleResultQueryFunc(file, name, timeOutDuration, query, dbInterfaces, outputType, inputFields={}, varArgsFilter=""):
    funcParams, callParams, queryDeclaration = computeQueryParams(query, dbInterfaces[ROW_QUERYER_CONTEXT], inputFields, varArgsFilter)

    file.Func().Id(name).Params(*funcParams).Parens(List(outputType, Error())).Block(
        addTimeOut(timeOutDuration),
        DEFER_CANCEL,
        Line(),
        queryDeclaration,
        Var().Id("valueTemp").Add(outputType),
        Err().Op(":=").Id("pool").Dot("QueryRowContext").Call(*callParams).Dot("Scan").Call(Op("&").Id("valueTemp")),
        Return(Id("valueTemp"), Err()),
    )

def MultiSimpleResultQueryFunc(file, name, timeOutDuration, query, dbInterfaces, outputType, inputFields={}, varArgsFilter=""):
    funcParams, callParams, queryDeclaration = computeQueryParams(query, dbInterfaces[QUERYER_CONTEXT], inputFields, varArgsFilter)

    file.Func().Id(name).Params(*funcParams).Parens(List(Op("[]").Add(outputType), Error())).Block(
        addTimeOut(timeOutDuration),
        DEFER_CANCEL,
        Line(),
        queryDeclaration,
        Var().Id("valueTemp").Add(outputType),
        List(Id("rows"), Err()).Op(":=").Id("pool").Dot("QueryContext").Call(*callParams),
        IF_ERR_NOT_NIL, DEFER_ROWS_CLOSE,
        Line(),

        Id("results").Op(":=").Op("[]").Add(outputType).Values(),
        FOR_ROWS_SCAN, RETURN_RESULTS,
    )

def ConvertedResultQueryFunc(file, name, timeOutDuration, query, dbInterfaces, queryResultFields, converter, outputType, inputFields={}, varArgsFilter=""):
    funcParams, callParams, queryDeclaration = computeQueryParams(query, dbInterfaces[ROW_QUERYER_CONTEXT], inputFields, varArgsFilter)

    instructions =  [
        addTimeOut(timeOutDuration),
        DEFER_CANCEL,
        Line(),
        queryDeclaration,
    ]

    callParams2, callParams3 = computeConvertParams(queryResultFields, instructions)

    instructions.append(Err().Op(":=").Id("pool").Dot("QueryRowContext").Call(*callParams).Dot("Scan").Call(*callParams2))
    instructions.append(Return(converter.Clone().Call(*callParams3), Err()))

    file.Func().Id(name).Params(*funcParams).Parens(List(outputType, Error())).Block(*instructions)

def MultiConvertedResultQueryFunc(file, name, timeOutDuration, query, dbInterfaces, queryResultFields, converter, outputType, inputFields={}, varArgsFilter=""):
    funcParams, callParams, queryDeclaration = computeQueryParams(query, dbInterfaces[QUERYER_CONTEXT], inputFields, varArgsFilter)

    instructions =  [
        addTimeOut(timeOutDuration),
        DEFER_CANCEL,
        Line(),
        queryDeclaration,
    ]

    callParams2, callParams3 = computeConvertParams(queryResultFields, instructions)

    instructions.append(List(Id("rows"), Err()).Op(":=").Id("pool").Dot("QueryContext").Call(*callParams))
    instructions.append(IF_ERR_NOT_NIL)
    instructions.append(DEFER_ROWS_CLOSE)
    instructions.append(Line())

    instructions.append(Id("results").Op(":=").Op("[]").Add(outputType).Values())
    instructions.append(For(Id("rows").Dot("Next").Call()).Block(
        Err().Op(":=").Id("rows").Dot("Scan").Call(*callParams2),
        IF_ERR_NOT_NIL,
        Id("results").Op("=").Append(Id("results"), converter.Clone().Call(*callParams3)),
    ))
    instructions.append(RETURN_RESULTS)

    file.Func().Id(name).Params(*funcParams).Parens(List(Op("[]").Add(outputType), Error())).Block(*instructions)

def ExecFunc(file, name, timeOutDuration, query, dbInterfaces, inputFields={}, varArgsFilter=""):
    funcParams, callParams, queryDeclaration = computeQueryParams(query, dbInterfaces[EXECER_CONTEXT], inputFields, varArgsFilter)

    file.Func().Id(name).Params(*funcParams).Parens(List(Int64(), Error())).Block(
        addTimeOut(timeOutDuration),
        DEFER_CANCEL,
        Line(),

        queryDeclaration,
        List(Id("result"), Err()).Op(":=").Id("pool").Dot("ExecContext").Call(*callParams),
        IF_ERR_NOT_NIL_ZERO,
        Return(Id("result").Dot("RowsAffected").Call()),
    )

def camelToUnderscore(s):
    res = []
    first = True
    for c in s.codepoints():
        if c.isupper():
            if not first:
                res.append("_")
            res.append(c.lower())
        else:
            res.append(c)
        first = False
    return "".join(res)

def BuildConvTypeDesc(typeName, fields):
    primaryKey = None
    computedFields = {}
    for k, v in fields.items():
        if primaryKey == None:
            primaryKey = k
        computedFields[k] = [v, camelToUnderscore(k)]

    return {
        TYPE_NAME: typeName,
        TABLE_NAME: camelToUnderscore(typeName) + "s",
        PRIMARY_KEY: primaryKey,
        FIELDS: computedFields,
    }

def GetNamedFields(typeDesc):
    namedFields = {}
    for fiedName, fieldData in  typeDesc[FIELDS].items():
        namedFields[fiedName] = fieldData[0]
    return namedFields

def CRUD(file, typeDesc, *, pointer=False, timeOutDuration, dbInterfaces):
    execerContext = dbInterfaces[EXECER_CONTEXT]

    typeName = typeDesc[TYPE_NAME] 
    primaryKey = typeDesc[PRIMARY_KEY] 
    namedFields = GetNamedFields(typeDesc)
    
    StructType(file, typeName, namedFields=namedFields)

    if pointer:
        builderName = "New" + typeName
        outputType = Op("*").Id(typeName)
        NewFunc(file, builderName, namedFields, Id(typeName))
    else:
        builderName = "Make" + typeName
        outputType = Id(typeName)
        MakeFunc(file, builderName, namedFields, outputType)    

    file.Line()

    createName = "create" + typeName
    createParams = [Id("pool"), Id("ctx")]
    for field in namedFields:
        createParams.append(Id("o").Dot(field))

    file.Func().Parens(Id("o").Add(outputType)).Id("Create").Params(Id("pool").Add(execerContext), Id("ctx").Qual("context", "Context")).Error().Block(
        List(Id("_"), Err()).Op(":=").Id(createName).Call(*createParams),
        Return(Err())
    )

    file.Line()

    primaryField = {primaryKey: namedFields[primaryKey]}

    ConvertedResultQueryFunc(
        file, name="Read" + typeName, timeOutDuration=timeOutDuration,
        query=selectByPrimaryKeyQuery(typeDesc),
        dbInterfaces=dbInterfaces, inputFields=primaryField, queryResultFields=namedFields,
        converter=Id(builderName), outputType=outputType,
    )

    file.Line()

    updateName = "update" + typeName

    file.Func().Parens(Id("o").Add(outputType)).Id("Update").Params(Id("pool").Add(execerContext), Id("ctx").Qual("context", "Context")).Error().Block(
        List(Id("_"), Err()).Op(":=").Id(updateName).Call(*createParams),
        Return(Err())
    )

    file.Line()

    deleteName = "delete" + typeName

    file.Func().Parens(Id("o").Add(outputType)).Id("Delete").Params(Id("pool").Add(execerContext), Id("ctx").Qual("context", "Context")).Error().Block(
        List(Id("_"), Err()).Op(":=").Id(deleteName).Call(Id("pool"), Id("ctx"), Id("o").Dot(primaryKey)),
        Return(Err())
    )

    file.Line()

    ExecFunc(
        file, name=createName, timeOutDuration=timeOutDuration,
        query=insertQuery(typeDesc),
        dbInterfaces=dbInterfaces, inputFields=namedFields,
    )

    file.Line()

    ExecFunc(
        file, name=updateName, timeOutDuration=timeOutDuration,
        query=updateQuery(typeDesc),
        dbInterfaces=dbInterfaces, inputFields=namedFields,
    )

    file.Line()

    ExecFunc(
        file, name=deleteName, timeOutDuration=timeOutDuration,
        query=deleteQuery(typeDesc),
        dbInterfaces=dbInterfaces, inputFields=primaryField,
    )

    return outputType, builderName

def ForeignKeyMethod(file, receiverType, *, multi=True, methodName, dbInterfaces, outputType, functionName, foreignKey):
    if multi:
        poolType = dbInterfaces[QUERYER_CONTEXT]
        outputType = Op("[]").Add(outputType)
    else:
        poolType = dbInterfaces[ROW_QUERYER_CONTEXT]
        outputType = outputType.Clone()

    file.Func().Parens(Id("o").Add(receiverType)).Id(methodName).Params(Id("pool").Add(poolType), Id("ctx").Qual("context", "Context")).Parens(List(outputType , Error())).Block(
        Return(Id(functionName).Call(Id("pool"), Id("ctx"), Id("o").Dot(foreignKey)))
    )
